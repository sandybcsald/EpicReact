{"ast":null,"code":"/* eslint-disable no-param-reassign */\nvar index = function (breakpoints) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      literal = _ref.literal,\n      overlap = _ref.overlap;\n\n  var mq = literal ? breakpoints : ['&'].concat(breakpoints);\n\n  function flatten(obj) {\n    if (typeof obj !== 'object' || obj == null) {\n      return [];\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(flatten);\n    }\n\n    var slots = {};\n    var objects = {};\n    var props = {};\n    Object.keys(obj).forEach(function (key) {\n      // Check if value is an array, but skip if it looks like a selector.\n      // key.indexOf('&') === 0\n      var item = obj[key];\n      if (!Array.isArray(item) && literal) item = [item];\n\n      if ((literal || Array.isArray(item)) && key.charCodeAt(0) !== 38) {\n        var prior = void 0;\n        item.forEach(function (v, index) {\n          // Optimize by removing duplicated media query entries\n          // when they are explicitly known to overlap.\n          if (overlap && prior === v) {\n            return;\n          }\n\n          if (v == null) {\n            // Do not create entries for undefined values as this will\n            // generate empty media media quries\n            return;\n          }\n\n          prior = v;\n\n          if (index === 0 && !literal) {\n            props[key] = v;\n          } else if (slots[mq[index]] === undefined) {\n            var _slots$mq$index;\n\n            slots[mq[index]] = (_slots$mq$index = {}, _slots$mq$index[key] = v, _slots$mq$index);\n          } else {\n            slots[mq[index]][key] = v;\n          }\n        });\n      } else if (typeof item === 'object') {\n        objects[key] = flatten(item);\n      } else {\n        props[key] = item;\n      }\n    }); // Ensure that all slots and then child objects are pushed to the end\n\n    mq.forEach(function (el) {\n      if (slots[el]) {\n        props[el] = slots[el];\n      }\n    });\n    Object.assign(props, objects);\n    return props;\n  }\n\n  return function () {\n    for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {\n      values[_key] = arguments[_key];\n    }\n\n    return values.map(flatten);\n  };\n};\n\nexport default index;","map":{"version":3,"sources":["../src/index.js"],"names":["literal","overlap","mq","obj","Array","slots","objects","props","item","key","prior","v","index","flatten","values"],"mappings":"AAAA;AACA,IAAA,KAAA,GAAe,UAAA,WAAA,EAAiD;iFAAJ,E;MAArBA,OAAyB,GAAA,IAAA,CAAzBA,O;MAASC,OAAgB,GAAA,IAAA,CAAhBA,O;;MACxCC,EAAAA,GAAKF,OAAAA,GAAAA,WAAAA,GAAwB,CAAA,GAAA,EAAA,MAAA,CAAnC,WAAmC,C;;WAEnC,O,CAAA,G,EAAsB;QAChB,OAAA,GAAA,KAAA,QAAA,IAA2BG,GAAAA,IAA/B,I,EAA4C;aAC1C,E;;;QAGEC,KAAAA,CAAAA,OAAAA,CAAJ,GAAIA,C,EAAoB;aACfD,GAAAA,CAAAA,GAAAA,CAAP,OAAOA,C;;;QAGHE,KAAAA,GAAN,E;QACMC,OAAAA,GAAN,E;QACMC,KAAAA,GAAN,E;WACA,I,CAAA,G,EAAA,O,CAAyB,UAAA,GAAA,EAAO;;;UAI1BC,IAAAA,GAAOL,GAAAA,CAAX,GAAWA,C;UACP,CAACC,KAAAA,CAAAA,OAAAA,CAAD,IAACA,CAAD,IAAJ,O,EAAqCI,IAAAA,GAAO,CAAPA,IAAO,CAAPA;;UAEjC,CAACR,OAAAA,IAAWI,KAAAA,CAAAA,OAAAA,CAAZ,IAAYA,CAAZ,KAAoCK,GAAAA,CAAAA,UAAAA,CAAAA,CAAAA,MAAxC,E,EAAkE;YAC5DC,KAAAA,GAAAA,KAAJ,C;aACA,O,CAAa,UAAA,CAAA,EAAA,KAAA,EAAc;;;cAGrBT,OAAAA,IAAWS,KAAAA,KAAf,C,EAA4B;;;;cAIxBC,CAAAA,IAAJ,I,EAAe;;;;;;kBAMf,C;;cAEIC,KAAAA,KAAAA,CAAAA,IAAe,CAAnB,O,EAA6B;kBAC3B,G,IAAA,C;AADF,W,MAEO,IAAIP,KAAAA,CAAMH,EAAAA,CAANG,KAAMH,CAANG,CAAAA,KAAJ,SAAA,EAAoC;;;kBACnCH,EAAAA,CAAN,KAAMA,C,KAAN,eAAA,GAAA,EAAA,EAAA,eAAA,CAAA,GAAA,CAAA,GAAA,CAAA,EAAA,e;AADK,WAAA,MAEA;kBACCA,EAAAA,CAAN,KAAMA,C,EAAN,G,IAAA,C;;AApBJ,S;AAFF,O,MAyBO,IAAI,OAAA,IAAA,KAAJ,QAAA,EAA8B;gBACnC,G,IAAeW,OAAAA,CAAf,IAAeA,C;AADV,OAAA,MAEA;cACL,G,IAAA,I;;AAnCJ,K,EAZoB,C;;OAoDpB,O,CAAW,UAAA,EAAA,EAAM;UACXR,KAAAA,CAAJ,EAAIA,C,EAAW;cACb,E,IAAYA,KAAAA,CAAZ,EAAYA,C;;AAFhB,K;WAKA,M,CAAA,K,EAAA,O;WACA,K;;;SAGK,YAAA;sCAAIS,MAAJ,GAAA,KAAA,CAAA,IAAA,C,EAAA,IAAA,GAAA,C,EAAA,IAAA,GAAA,I,EAAA,IAAA,E,EAAA;YAAA,CAAA,IAAA,C,GAAA,SAAA,CAAA,IAAA,C;;;WAAeA,MAAAA,CAAAA,GAAAA,CAAf,OAAeA,C;AAAtB,G;CAhEF","sourcesContent":["/* eslint-disable no-param-reassign */\nexport default function(breakpoints, { literal, overlap } = {}) {\n  const mq = literal ? breakpoints : ['&'].concat(breakpoints)\n\n  function flatten(obj) {\n    if (typeof obj !== 'object' || obj == null) {\n      return []\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(flatten)\n    }\n\n    const slots = {}\n    const objects = {}\n    const props = {}\n    Object.keys(obj).forEach(key => {\n      // Check if value is an array, but skip if it looks like a selector.\n      // key.indexOf('&') === 0\n\n      let item = obj[key]\n      if (!Array.isArray(item) && literal) item = [item]\n\n      if ((literal || Array.isArray(item)) && key.charCodeAt(0) !== 38) {\n        let prior\n        item.forEach((v, index) => {\n          // Optimize by removing duplicated media query entries\n          // when they are explicitly known to overlap.\n          if (overlap && prior === v) {\n            return\n          }\n\n          if (v == null) {\n            // Do not create entries for undefined values as this will\n            // generate empty media media quries\n            return\n          }\n\n          prior = v\n\n          if (index === 0 && !literal) {\n            props[key] = v\n          } else if (slots[mq[index]] === undefined) {\n            slots[mq[index]] = { [key]: v }\n          } else {\n            slots[mq[index]][key] = v\n          }\n        })\n      } else if (typeof item === 'object') {\n        objects[key] = flatten(item)\n      } else {\n        props[key] = item\n      }\n    })\n\n    // Ensure that all slots and then child objects are pushed to the end\n    mq.forEach(el => {\n      if (slots[el]) {\n        props[el] = slots[el];\n      }\n    })\n    Object.assign(props, objects)\n    return props\n  }\n\n  return (...values) => values.map(flatten)\n}\n"]},"metadata":{},"sourceType":"module"}