{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeHttpRequestParams = void 0;\n\nvar getRequestOptionsByUrl_1 = require(\"../../../utils/getRequestOptionsByUrl\");\n\nvar getUrlByRequestOptions_1 = require(\"../../../utils/getUrlByRequestOptions\");\n\nvar cloneObject_1 = require(\"../../../utils/cloneObject\");\n\nvar isObject_1 = require(\"../../../utils/isObject\");\n\nvar debug = require('debug')('http normalizeHttpRequestParams');\n\nfunction resolveRequestOptions(args, url) {\n  // Calling `fetch` provides only URL to ClientRequest,\n  // without RequestOptions or callback.\n  if (['function', 'undefined'].includes(typeof args[1])) {\n    return getRequestOptionsByUrl_1.getRequestOptionsByUrl(url);\n  }\n  /**\n   * Clone the request options to lock their state\n   * at the moment they are provided to `ClientRequest.\n   * @see https://github.com/mswjs/node-request-interceptor/issues/86\n   */\n\n\n  return args[1] ? cloneObject_1.cloneObject(args[1]) : {};\n}\n\nfunction resolveCallback(args) {\n  return typeof args[1] === 'function' ? args[1] : args[2];\n}\n/**\n * Normalizes parameters given to a `http.request` call\n * so it always has a `URL` and `RequestOptions`.\n */\n\n\nfunction normalizeHttpRequestParams(defaultProtocol) {\n  var args = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n\n  var url;\n  var options;\n  var callback;\n  debug('arguments', args);\n  debug('default protocol', defaultProtocol); // Convert a url string into a URL instance\n  // and derive request options from it.\n\n  if (typeof args[0] === 'string') {\n    debug('given a location string:', args[0]);\n    url = new URL(args[0]);\n    debug('created a URL:', url);\n    options = resolveRequestOptions(args, url);\n    debug('created request options:', options);\n    callback = resolveCallback(args);\n  } // Handle a given URL instance as-is\n  // and derive request options from it.\n  else if ('origin' in args[0]) {\n    url = args[0];\n    debug('given a URL:', url);\n    options = resolveRequestOptions(args, url);\n    debug('created request options', options);\n    callback = resolveCallback(args);\n  } // Handle a legacy URL instance and re-normalize from either a RequestOptions object\n  // or a WHATWG URL.\n  else if ('hash' in args[0] && !('method' in args[0])) {\n    var _a = __read(args, 1),\n        legacyUrl = _a[0];\n\n    if (legacyUrl.hostname === null) {\n      // We are dealing with a relative url, so use the path as an \"option\" and\n      // merge in any existing options, giving priority to exising options -- i.e. a path in any\n      // existing options will take precedence over the one contained in the url. This is consistent\n      // with the behaviour in ClientRequest.\n      // https://github.com/nodejs/node/blob/d84f1312915fe45fe0febe888db692c74894c382/lib/_http_client.js#L122\n      debug('given a relative legacy URL:', legacyUrl);\n      return isObject_1.isObject(args[1]) ? normalizeHttpRequestParams(defaultProtocol, __assign({\n        path: legacyUrl.path\n      }, args[1]), args[2]) : normalizeHttpRequestParams(defaultProtocol, {\n        path: legacyUrl.path\n      }, args[1]);\n    }\n\n    debug('given an absolute legacy url:', legacyUrl); // We are dealing with an absolute URL, so convert to WHATWG and try again.\n\n    var resolvedUrl = new URL(legacyUrl.href);\n    return args[1] === undefined ? normalizeHttpRequestParams(defaultProtocol, resolvedUrl) : typeof args[1] === 'function' ? normalizeHttpRequestParams(defaultProtocol, resolvedUrl, args[1]) : normalizeHttpRequestParams(defaultProtocol, resolvedUrl, args[1], args[2]);\n  } // Handle a given RequestOptions object as-is\n  // and derive the URL instance from it.\n  else if (isObject_1.isObject(args[0])) {\n    options = args[0];\n    debug('given request options:', options); // When handling a `RequestOptions` object without an explicit \"protocol\",\n    // infer the protocol from the request issuing module (http/https).\n\n    options.protocol = options.protocol || defaultProtocol;\n    debug('normalized request options:', options);\n    url = getUrlByRequestOptions_1.getUrlByRequestOptions(options);\n    debug('created a URL:', url);\n    callback = resolveCallback(args);\n  } else {\n    throw new Error(\"Failed to construct ClientRequest with these parameters: \" + args);\n  } // Enforce protocol on `RequestOptions` so when `ClientRequest` compares\n  // the agent protocol to the request options protocol they match.\n  // @see https://github.com/nodejs/node/blob/d84f1312915fe45fe0febe888db692c74894c382/lib/_http_client.js#L142-L145\n  // This prevents `Protocol \"http:\" not supported. Expected \"https:\"` exception for `https.request` calls.\n\n\n  options.protocol = options.protocol || url.protocol;\n  options.method = options.method || 'GET';\n  debug('resolved URL:', url);\n  debug('resolved options:', options);\n  return [url, options, callback];\n}\n\nexports.normalizeHttpRequestParams = normalizeHttpRequestParams;","map":{"version":3,"sources":["../../../../src/interceptors/ClientRequest/utils/normalizeHttpRequestParams.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.normalizeHttpRequestParams = void 0;\nvar getRequestOptionsByUrl_1 = require(\"../../../utils/getRequestOptionsByUrl\");\nvar getUrlByRequestOptions_1 = require(\"../../../utils/getUrlByRequestOptions\");\nvar cloneObject_1 = require(\"../../../utils/cloneObject\");\nvar isObject_1 = require(\"../../../utils/isObject\");\nvar debug = require('debug')('http normalizeHttpRequestParams');\nfunction resolveRequestOptions(args, url) {\n    // Calling `fetch` provides only URL to ClientRequest,\n    // without RequestOptions or callback.\n    if (['function', 'undefined'].includes(typeof args[1])) {\n        return getRequestOptionsByUrl_1.getRequestOptionsByUrl(url);\n    }\n    /**\n     * Clone the request options to lock their state\n     * at the moment they are provided to `ClientRequest.\n     * @see https://github.com/mswjs/node-request-interceptor/issues/86\n     */\n    return args[1] ? cloneObject_1.cloneObject(args[1]) : {};\n}\nfunction resolveCallback(args) {\n    return typeof args[1] === 'function' ? args[1] : args[2];\n}\n/**\n * Normalizes parameters given to a `http.request` call\n * so it always has a `URL` and `RequestOptions`.\n */\nfunction normalizeHttpRequestParams(defaultProtocol) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    var url;\n    var options;\n    var callback;\n    debug('arguments', args);\n    debug('default protocol', defaultProtocol);\n    // Convert a url string into a URL instance\n    // and derive request options from it.\n    if (typeof args[0] === 'string') {\n        debug('given a location string:', args[0]);\n        url = new URL(args[0]);\n        debug('created a URL:', url);\n        options = resolveRequestOptions(args, url);\n        debug('created request options:', options);\n        callback = resolveCallback(args);\n    }\n    // Handle a given URL instance as-is\n    // and derive request options from it.\n    else if ('origin' in args[0]) {\n        url = args[0];\n        debug('given a URL:', url);\n        options = resolveRequestOptions(args, url);\n        debug('created request options', options);\n        callback = resolveCallback(args);\n    }\n    // Handle a legacy URL instance and re-normalize from either a RequestOptions object\n    // or a WHATWG URL.\n    else if ('hash' in args[0] && !('method' in args[0])) {\n        var _a = __read(args, 1), legacyUrl = _a[0];\n        if (legacyUrl.hostname === null) {\n            // We are dealing with a relative url, so use the path as an \"option\" and\n            // merge in any existing options, giving priority to exising options -- i.e. a path in any\n            // existing options will take precedence over the one contained in the url. This is consistent\n            // with the behaviour in ClientRequest.\n            // https://github.com/nodejs/node/blob/d84f1312915fe45fe0febe888db692c74894c382/lib/_http_client.js#L122\n            debug('given a relative legacy URL:', legacyUrl);\n            return isObject_1.isObject(args[1])\n                ? normalizeHttpRequestParams(defaultProtocol, __assign({ path: legacyUrl.path }, args[1]), args[2])\n                : normalizeHttpRequestParams(defaultProtocol, { path: legacyUrl.path }, args[1]);\n        }\n        debug('given an absolute legacy url:', legacyUrl);\n        // We are dealing with an absolute URL, so convert to WHATWG and try again.\n        var resolvedUrl = new URL(legacyUrl.href);\n        return args[1] === undefined\n            ? normalizeHttpRequestParams(defaultProtocol, resolvedUrl)\n            : typeof args[1] === 'function'\n                ? normalizeHttpRequestParams(defaultProtocol, resolvedUrl, args[1])\n                : normalizeHttpRequestParams(defaultProtocol, resolvedUrl, args[1], args[2]);\n    }\n    // Handle a given RequestOptions object as-is\n    // and derive the URL instance from it.\n    else if (isObject_1.isObject(args[0])) {\n        options = args[0];\n        debug('given request options:', options);\n        // When handling a `RequestOptions` object without an explicit \"protocol\",\n        // infer the protocol from the request issuing module (http/https).\n        options.protocol = options.protocol || defaultProtocol;\n        debug('normalized request options:', options);\n        url = getUrlByRequestOptions_1.getUrlByRequestOptions(options);\n        debug('created a URL:', url);\n        callback = resolveCallback(args);\n    }\n    else {\n        throw new Error(\"Failed to construct ClientRequest with these parameters: \" + args);\n    }\n    // Enforce protocol on `RequestOptions` so when `ClientRequest` compares\n    // the agent protocol to the request options protocol they match.\n    // @see https://github.com/nodejs/node/blob/d84f1312915fe45fe0febe888db692c74894c382/lib/_http_client.js#L142-L145\n    // This prevents `Protocol \"http:\" not supported. Expected \"https:\"` exception for `https.request` calls.\n    options.protocol = options.protocol || url.protocol;\n    options.method = options.method || 'GET';\n    debug('resolved URL:', url);\n    debug('resolved options:', options);\n    return [url, options, callback];\n}\nexports.normalizeHttpRequestParams = normalizeHttpRequestParams;\n//# sourceMappingURL=normalizeHttpRequestParams.js.map"]},"metadata":{},"sourceType":"script"}